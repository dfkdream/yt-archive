// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const getChannel = `-- name: GetChannel :one
select id, title, description, thumbnail from channels
where channels.id=?
`

func (q *Queries) GetChannel(ctx context.Context, id string) (Channel, error) {
	row := q.db.QueryRowContext(ctx, getChannel, id)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Thumbnail,
	)
	return i, err
}

const getChannelVideos = `-- name: GetChannelVideos :many
select
    v.id, v.title, v.description, v.timestamp, v.duration, v.owner, v.thumbnail, c.id, c.title, c.description, c.thumbnail
from videos as v
left join channels as c
on v.owner = c.id
where v.owner=?
order by v.rowid desc
`

type GetChannelVideosRow struct {
	Video   Video
	Channel Channel
}

func (q *Queries) GetChannelVideos(ctx context.Context, owner string) ([]GetChannelVideosRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelVideos, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelVideosRow
	for rows.Next() {
		var i GetChannelVideosRow
		if err := rows.Scan(
			&i.Video.ID,
			&i.Video.Title,
			&i.Video.Description,
			&i.Video.Timestamp,
			&i.Video.Duration,
			&i.Video.Owner,
			&i.Video.Thumbnail,
			&i.Channel.ID,
			&i.Channel.Title,
			&i.Channel.Description,
			&i.Channel.Thumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannels = `-- name: GetChannels :many
select id, title, description, thumbnail from channels
`

// api/channels.go
func (q *Queries) GetChannels(ctx context.Context) ([]Channel, error) {
	rows, err := q.db.QueryContext(ctx, getChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Channel
	for rows.Next() {
		var i Channel
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Thumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistVideos = `-- name: GetPlaylistVideos :many
select 
    p.id, p.title, p.description, p.timestamp, p.owner, c.id, c.title, c.description, c.thumbnail, v.id, v.title, v.description, v.timestamp, v.duration, v.owner, v.thumbnail, vc.id, vc.title, vc.description, vc.thumbnail, pv.sortIndex
from playlists as p
left join channels as c
on p.owner=c.id
left join playlist_video as pv
on p.id=pv.playlistId
left join videos as v
on pv.videoId=v.id	
left join channels as vc
on v.owner=vc.id
where p.id=?
order by pv.sortIndex asc, v.timestamp asc
`

type GetPlaylistVideosRow struct {
	Playlist  Playlist
	Channel   Channel
	Video     Video
	Channel_2 Channel
	Sortindex sql.NullInt64
}

func (q *Queries) GetPlaylistVideos(ctx context.Context, id string) ([]GetPlaylistVideosRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylistVideos, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistVideosRow
	for rows.Next() {
		var i GetPlaylistVideosRow
		if err := rows.Scan(
			&i.Playlist.ID,
			&i.Playlist.Title,
			&i.Playlist.Description,
			&i.Playlist.Timestamp,
			&i.Playlist.Owner,
			&i.Channel.ID,
			&i.Channel.Title,
			&i.Channel.Description,
			&i.Channel.Thumbnail,
			&i.Video.ID,
			&i.Video.Title,
			&i.Video.Description,
			&i.Video.Timestamp,
			&i.Video.Duration,
			&i.Video.Owner,
			&i.Video.Thumbnail,
			&i.Channel_2.ID,
			&i.Channel_2.Title,
			&i.Channel_2.Description,
			&i.Channel_2.Thumbnail,
			&i.Sortindex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylists = `-- name: GetPlaylists :many
select 
    p.id, p.title, p.description, p.timestamp, p.owner, c.id, c.title, c.description, c.thumbnail, v.id, v.title, v.description, v.timestamp, v.duration, v.owner, v.thumbnail
from playlists as p
left join channels as c
on p.owner=c.id
left join playlist_video as pv
on p.id=pv.playlistId
left join videos as v
on pv.videoId=v.id	
where c.thumbnail not null
and v.id not null
order by p.rowid desc, pv.sortIndex asc, v.timestamp asc
`

type GetPlaylistsRow struct {
	Playlist Playlist
	Channel  Channel
	Video    Video
}

// api/playlists.go
func (q *Queries) GetPlaylists(ctx context.Context) ([]GetPlaylistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistsRow
	for rows.Next() {
		var i GetPlaylistsRow
		if err := rows.Scan(
			&i.Playlist.ID,
			&i.Playlist.Title,
			&i.Playlist.Description,
			&i.Playlist.Timestamp,
			&i.Playlist.Owner,
			&i.Channel.ID,
			&i.Channel.Title,
			&i.Channel.Description,
			&i.Channel.Thumbnail,
			&i.Video.ID,
			&i.Video.Title,
			&i.Video.Description,
			&i.Video.Timestamp,
			&i.Video.Duration,
			&i.Video.Owner,
			&i.Video.Thumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideo = `-- name: GetVideo :one
select
    videos.id, videos.title, videos.description, videos.timestamp, videos.duration, videos.owner, videos.thumbnail, channels.id, channels.title, channels.description, channels.thumbnail
from videos
left join channels
on videos.owner = channels.id
where videos.id=?
`

type GetVideoRow struct {
	Video   Video
	Channel Channel
}

func (q *Queries) GetVideo(ctx context.Context, id string) (GetVideoRow, error) {
	row := q.db.QueryRowContext(ctx, getVideo, id)
	var i GetVideoRow
	err := row.Scan(
		&i.Video.ID,
		&i.Video.Title,
		&i.Video.Description,
		&i.Video.Timestamp,
		&i.Video.Duration,
		&i.Video.Owner,
		&i.Video.Thumbnail,
		&i.Channel.ID,
		&i.Channel.Title,
		&i.Channel.Description,
		&i.Channel.Thumbnail,
	)
	return i, err
}

const getVideos = `-- name: GetVideos :many
select 
    videos.id, videos.title, videos.description, videos.timestamp, videos.duration, videos.owner, videos.thumbnail, channels.id, channels.title, channels.description, channels.thumbnail
from videos
left join channels
on videos.owner = channels.id
order by videos.rowid desc
`

type GetVideosRow struct {
	Video   Video
	Channel Channel
}

// api/videos.go
func (q *Queries) GetVideos(ctx context.Context) ([]GetVideosRow, error) {
	rows, err := q.db.QueryContext(ctx, getVideos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVideosRow
	for rows.Next() {
		var i GetVideosRow
		if err := rows.Scan(
			&i.Video.ID,
			&i.Video.Title,
			&i.Video.Description,
			&i.Video.Timestamp,
			&i.Video.Duration,
			&i.Video.Owner,
			&i.Video.Thumbnail,
			&i.Channel.ID,
			&i.Channel.Title,
			&i.Channel.Description,
			&i.Channel.Thumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlaylistVideoIndex = `-- name: UpdatePlaylistVideoIndex :execrows
update playlist_video 
set sortIndex=? 
where playlistId=? and videoId=?
`

type UpdatePlaylistVideoIndexParams struct {
	Sortindex  int64
	Playlistid string
	Videoid    string
}

func (q *Queries) UpdatePlaylistVideoIndex(ctx context.Context, arg UpdatePlaylistVideoIndexParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updatePlaylistVideoIndex, arg.Sortindex, arg.Playlistid, arg.Videoid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
